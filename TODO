-> addVarables -> ajouter des RationalNumber etc.., pas des BaseAssignementValue
-> identifier le type d'input en premier, créer l'objet associé,
    puis appliquer les fonctions de parsing de la class correspondante
-> Impossible de créer une variable nommé 'i'
-> Pendant l'expander, checker les variables de + de 1 caractère
-> Les nombres décimaux

-> check si l'input contient '= ?'
    -> calculer la partie gauche de l'expression, retourner le résultat de cette dernière

Matrices :
-> utiliser regex pour la syntax
-> forme x = ai + b
-> les input peuvent être: 2*i+3, 2i + 3, 3 + 2*i ou 3 + 2i
    -> in fine, réorganiser pour avoir la forme 3 + 2i
    -> signe négatif possible
-> isinstance(expression, complex) ??
-> multiplication de matrices entre elle ou par le biais d'un scalar

Fonctions:
-> quand une fonction est défini, je l'ajoute au tableau de variables
-> pour l'expander, check que le nom est correct, puis '(', while isdigit(); i++, puis ')'

Regex: avec re.match() -> regex101
    -> Nombres complexes:
        -> ^-?\d*(\.\d+)?i$ pour une simple partie imaginaire et ^-?\d+(\.\d+)?\s*[+-]\s*\d*(\.\d+)?i$ pour une combinaison réelle + imaginaire.

    -> Nombres rationels:
        -> ^-?\d+(\.\d+)?$ pour les entiers et les décimaux, et ^-?\d+/\d+$ pour les fractions.

    -> Fonctions:
        -> ^[a-zA-Z_][a-zA-Z0-9_]*\s*\(\s*[a-zA-Z_][a-zA-Z0-9_]*(\s*,\s*[a-zA-Z_][a-zA-Z0-9_]*)*\s*\)$ pour identifier une fonction avec paramètres ou simplement vérifier la présence d'une variable dans une expression.
    
    -> Matrices:
        -> ^\[\s*(-?\d+(\.\d+)?\s*(,\s*-?\d+(\.\d+)?)*)(\s*;\s*(-?\d+(\.\d+)?\s*(,\s*-?\d+(\.\d+)?)*))*\s*\]$ pour capturer une matrice.